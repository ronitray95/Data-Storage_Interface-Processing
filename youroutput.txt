{'_id': '10.1145/2635648.2635660', 'series': "ILC '14", 'location': 'Montreal, QC, Canada', 'keywords': 'Interoperability, Racket, Python', 'numpages': '7', 'pages': '32–38', 'booktitle': 'Proceedings of ILC 2014 on 8th International Lisp Conference', 'abstract': "Racket is a descendant of Scheme, a language that has been widely used to teach computer science. Recently, the Python language has taken over this role, mainly due to its huge standard library and the great number of third-party libraries available. Given that the development of equivalent libraries for Racket is an enormous task that cannot be currently done in an acceptable time frame, the next best option is to allow the Racket platform to use Python programs and libraries.We have been developing an implementation of Python for the Racket platform based on a source-to-source compiler. In order to provide good performance and good interoperability with the Racket platform, the runtime libraries are being implemented over Racket data-types. This, however, entails implementing all of Python's standard library on Racket and it does not provide access to popular Python libraries implemented using C module extensions (such as Numpy and SciPy).This paper presents an alternative approach that allows libraries from Python's reference implementation to be imported and used in our Racket implementation of Python, immediately providing access to all of Python's standard library and every third-party library, including NumPy and SciPy.The proposed solution involves importing Python module objects directly from Python's virtual machine, by calling the Python/C API through Racket's Foreign Function Interface, and converting them to objects usable by our Racket runtime libraries, making them compatible with the Racket platform.This compatibility layer therefore relies on relatively expensive foreign function calls to Python's libraries, but our performance tests show that the overhead introduced by them is quite low and, for most cases, it can be minimized in order to attain the same performance as Python's reference implementation.", 'url': 'https://doi.org/10.1145/2635648.2635660', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450329316', 'year': '2014', 'title': 'Reaching Python from Racket', 'author': "Ramos, Pedro Palma and Leit\\~{a}o, Ant\\'{o}nio Menezes", 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2635648.2635660'}
{'_id': '10.1145/2617548.2617552', 'series': "Dyla'14", 'location': 'Edinburgh, United Kingdom', 'keywords': 'dynamic programming languages, reference counting, unboxing, Python, interpreters', 'numpages': '9', 'pages': '1–9', 'booktitle': 'Proceedings of the Workshop on Dynamic Languages and Applications', 'abstract': "The Python programming language is known for performing poorly on many tasks. While to some extent this is to be expected from a dynamic language, it is not clear how much each dynamic feature contributes to the costs of interpreting Python. In this study we attempt to quantify the costs of language features such as dynamic typing, reference counting for memory management, boxing of numbers, and late binding of function calls.We use an experimental compilation framework for Python that can make use of type annotations provided by the user to specialize the program as well as elide unnecessary reference counting operations and function lookups. The compiled programs run within the Python interpreter and use its internal API to implement language semantics. By separately enabling and disabling compiler optimizations, we can thus measure how much each language feature contributes to total execution time in the interpreter.We find that a boxed representation of numbers as heap objects is the single most costly language feature on numeric codes, accounting for up to 43% of total execution time in our benchmark set. On symbolic object-oriented code, late binding of function and method calls costs up to 30%. Redundant reference counting, dynamic type checks, and Python's elaborate function calling convention have comparatively smaller costs.", 'url': 'https://doi.org/10.1145/2617548.2617552', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450329163', 'year': '2014', 'title': 'Python Interpreter Performance Deconstructed', 'author': 'Barany, Gerg\\"{o}', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2617548.2617552'}
{'_id': '10.1145/2445196.2445368', 'series': "SIGCSE '13", 'location': 'Denver, Colorado, USA', 'keywords': 'CS1, python, program visualization', 'numpages': '6', 'pages': '579–584', 'booktitle': 'Proceeding of the 44th ACM Technical Symposium on Computer Science Education', 'abstract': 'This paper presents Online Python Tutor, a web-based program visualization tool for Python, which is becoming a popular language for teaching introductory CS courses. Using this tool, teachers and students can write Python programs directly in the web browser (without installing any plugins), step forwards and backwards through execution to view the run-time state of data structures, and share their program visualizations on the web. In the past three years, over 200,000 people have used Online Python Tutor to visualize their programs. In addition, instructors in a dozen universities such as UC Berkeley, MIT, the University of Washington, and the University of Waterloo have used it in their CS1 courses. Finally, Online Python Tutor visualizations have been embedded within three web-based digital Python textbook projects, which collectively attract around 16,000 viewers per month and are being used in at least 25 universities. Online Python Tutor is free and open source software, available at pythontutor.com.', 'url': 'https://doi.org/10.1145/2445196.2445368', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450318686', 'year': '2013', 'title': 'Online Python Tutor: Embeddable Web-Based Program Visualization for Cs Education', 'author': 'Guo, Philip J.', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2445196.2445368'}
{'_id': '10.1145/2597073.2597103', 'series': 'MSR 2014', 'location': 'Hyderabad, India', 'keywords': 'Python, dynamic features, Dynamic languages, open source', 'numpages': '4', 'pages': '292–295', 'booktitle': 'Proceedings of the 11th Working Conference on Mining Software Repositories', 'abstract': ' Recent years have seen a number of proposals for adding (retrofitting) static typing to dynamic programming languages, a natural consequence of their growing popularity for non-toy applications across a multitude of domains. These proposals often make assumptions about how programmers write code, and in many cases restrict the way the languages can be used. In the context of Python, this paper describes early results from trace-based collection of run-time data about the use of built-in language features which are inherently hard to type, such as dynamic code generation. The end goal of this work is to facilitate static validation tooling for Python, in particular retrofitting of type systems. ', 'url': 'https://doi.org/10.1145/2597073.2597103', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450328630', 'year': '2014', 'title': 'Tracing Dynamic Features in Python Programs', 'author': '\\r{A}kerblom, Beatrice and Stendahl, Jonathan and Tumlin, Mattias and Wrigstad, Tobias', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2597073.2597103'}
{'_id': '10.1145/2816707.2816717', 'series': 'DLS 2015', 'location': 'Pittsburgh, PA, USA', 'keywords': 'trace-based analysis, polymorphism, dynamic languages, Python', 'numpages': '15', 'pages': '114–128', 'booktitle': 'Proceedings of the 11th Symposium on Dynamic Languages', 'abstract': " Following the increased popularity of dynamic languages and their increased use in critical software, there have been many proposals to retrofit static type system to these languages to improve possibilities to catch bugs and improve performance. A key question for any type system is whether the types should be structural, for more expressiveness, or nominal, to carry more meaning for the programmer. For retrofitted type systems, it seems the current trend is using structural types. This paper attempts to answer the question to what extent this extra expressiveness is needed, and how the possible polymorphism in dynamic code is used in practise. We study polymorphism in 36 real-world open source Python programs and approximate to what extent nominal and structural types could be used to type these programs. The study is based on collecting traces from multiple runs of the programs and analysing the polymorphic degrees of targets at more than 7 million call-sites. Our results show that while polymorphism is used in all programs, the programs are to a great extent monomorphic. The polymorphism found is evenly distributed across libraries and program-specific code and occur both during program start-up and normal execution. Most programs contain a few ``megamorphic'' call-sites where receiver types vary widely. The non-monomorphic parts of the programs can to some extent be typed with nominal or structural types, but none of the approaches can type entire programs. ", 'url': 'https://doi.org/10.1145/2816707.2816717', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450336901', 'year': '2015', 'title': 'Measuring Polymorphism in Python Programs', 'author': '\\r{A}kerblom, Beatrice and Wrigstad, Tobias', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2816707.2816717'}
{'_id': '10.1145/2936313.2816717', 'keywords': 'polymorphism, dynamic languages, trace-based analysis, Python', 'numpages': '15', 'pages': '114–128', 'month': 'October', 'journal': 'SIGPLAN Not.', 'abstract': " Following the increased popularity of dynamic languages and their increased use in critical software, there have been many proposals to retrofit static type system to these languages to improve possibilities to catch bugs and improve performance. A key question for any type system is whether the types should be structural, for more expressiveness, or nominal, to carry more meaning for the programmer. For retrofitted type systems, it seems the current trend is using structural types. This paper attempts to answer the question to what extent this extra expressiveness is needed, and how the possible polymorphism in dynamic code is used in practise. We study polymorphism in 36 real-world open source Python programs and approximate to what extent nominal and structural types could be used to type these programs. The study is based on collecting traces from multiple runs of the programs and analysing the polymorphic degrees of targets at more than 7 million call-sites. Our results show that while polymorphism is used in all programs, the programs are to a great extent monomorphic. The polymorphism found is evenly distributed across libraries and program-specific code and occur both during program start-up and normal execution. Most programs contain a few ``megamorphic'' call-sites where receiver types vary widely. The non-monomorphic parts of the programs can to some extent be typed with nominal or structural types, but none of the approaches can type entire programs. ", 'url': 'https://doi.org/10.1145/2936313.2816717', 'issn': '0362-1340', 'number': '2', 'volume': '51', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'issue_date': 'Feburary 2016', 'year': '2015', 'title': 'Measuring Polymorphism in Python Programs', 'author': '\\r{A}kerblom, Beatrice and Wrigstad, Tobias', 'ENTRYTYPE': 'article', 'ID': '10.1145/2936313.2816717'}
{'_id': '10.1145/2661088.2661101', 'series': "DLS '14", 'location': 'Portland, Oregon, USA', 'keywords': 'python, proxy, gradual typing, case study', 'numpages': '12', 'pages': '45–56', 'booktitle': 'Proceedings of the 10th ACM Symposium on Dynamic Languages', 'abstract': 'Combining static and dynamic typing within the same language offers clear benefits to programmers. It provides dynamic typing in situations that require rapid prototyping, heterogeneous data structures, and reflection, while supporting static typing when safety, modularity, and efficiency are primary concerns. Siek and Taha (2006) introduced an approach to combining static and dynamic typing in a fine-grained manner through the notion of type consistency in the static semantics and run-time casts in the dynamic semantics. However, many open questions remain regarding the semantics of gradually typed languages.In this paper we present Reticulated Python, a system for experimenting with gradual-typed dialects of Python. The dialects are syntactically identical to Python 3 but give static and dynamic semantics to the type annotations already present in Python 3. Reticulated Python consists of a typechecker and a source-to-source translator from Reticulated Python to Python 3. Using Reticulated Python, we evaluate a gradual type system and three approaches to the dynamic semantics of mutable objects: the traditional semantics based on Siek and Taha (2007) and Herman et al. (2007) and two new designs. We evaluate these designs in the context of several third-party Python programs.', 'url': 'https://doi.org/10.1145/2661088.2661101', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450332118', 'year': '2014', 'title': 'Design and Evaluation of Gradual Typing for Python', 'author': 'Vitousek, Michael M. and Kent, Andrew M. and Siek, Jeremy G. and Baker, Jim', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2661088.2661101'}
{'_id': '10.1145/2775052.2661101', 'keywords': 'python, proxy, gradual typing, case study', 'numpages': '12', 'pages': '45–56', 'month': 'October', 'journal': 'SIGPLAN Not.', 'abstract': 'Combining static and dynamic typing within the same language offers clear benefits to programmers. It provides dynamic typing in situations that require rapid prototyping, heterogeneous data structures, and reflection, while supporting static typing when safety, modularity, and efficiency are primary concerns. Siek and Taha (2006) introduced an approach to combining static and dynamic typing in a fine-grained manner through the notion of type consistency in the static semantics and run-time casts in the dynamic semantics. However, many open questions remain regarding the semantics of gradually typed languages.In this paper we present Reticulated Python, a system for experimenting with gradual-typed dialects of Python. The dialects are syntactically identical to Python 3 but give static and dynamic semantics to the type annotations already present in Python 3. Reticulated Python consists of a typechecker and a source-to-source translator from Reticulated Python to Python 3. Using Reticulated Python, we evaluate a gradual type system and three approaches to the dynamic semantics of mutable objects: the traditional semantics based on Siek and Taha (2007) and Herman et al. (2007) and two new designs. We evaluate these designs in the context of several third-party Python programs.', 'url': 'https://doi.org/10.1145/2775052.2661101', 'issn': '0362-1340', 'number': '2', 'volume': '50', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'issue_date': 'February 2015', 'year': '2014', 'title': 'Design and Evaluation of Gradual Typing for Python', 'author': 'Vitousek, Michael M. and Kent, Andrew M. and Siek, Jeremy G. and Baker, Jim', 'ENTRYTYPE': 'article', 'ID': '10.1145/2775052.2661101'}
{'_id': '10.1145/2509136.2509536', 'series': "OOPSLA '13", 'location': 'Indianapolis, Indiana, USA', 'keywords': 'serpents', 'numpages': '16', 'pages': '217–232', 'booktitle': 'Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages &amp; Applications', 'abstract': 'We present a small-step operational semantics for the Python programming language. We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core. We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.', 'url': 'https://doi.org/10.1145/2509136.2509536', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450323741', 'year': '2013', 'title': 'Python: The Full Monty', 'author': 'Politz, Joe Gibbs and Martinez, Alejandro and Milano, Matthew and Warren, Sumner and Patterson, Daniel and Li, Junsong and Chitipothu, Anand and Krishnamurthi, Shriram', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2509136.2509536'}
{'_id': '10.1145/2544173.2509536', 'keywords': 'serpents', 'numpages': '16', 'pages': '217–232', 'month': 'October', 'journal': 'SIGPLAN Not.', 'abstract': 'We present a small-step operational semantics for the Python programming language. We present both a core language for Python, suitable for tools and proofs, and a translation process for converting Python source to this core. We have tested the composition of translation and evaluation of the core for conformance with the primary Python implementation, thereby giving confidence in the fidelity of the semantics. We briefly report on the engineering of these components. Finally, we examine subtle aspects of the language, identifying scope as a pervasive concern that even impacts features that might be considered orthogonal.', 'url': 'https://doi.org/10.1145/2544173.2509536', 'issn': '0362-1340', 'number': '10', 'volume': '48', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'issue_date': 'October 2013', 'year': '2013', 'title': 'Python: The Full Monty', 'author': 'Politz, Joe Gibbs and Martinez, Alejandro and Milano, Matthew and Warren, Sumner and Patterson, Daniel and Li, Junsong and Chitipothu, Anand and Krishnamurthi, Shriram', 'ENTRYTYPE': 'article', 'ID': '10.1145/2544173.2509536'}
{'_id': '10.1145/2808006.2808017', 'series': "SIGITE '15", 'location': 'Chicago, Illinois, USA', 'keywords': 'python, novice programming, reference errors, inheritance', 'numpages': '6', 'pages': '59–64', 'booktitle': 'Proceedings of the 16th Annual Conference on Information Technology Education', 'abstract': 'We report a small yet detailed study where we recorded students completing an object-oriented programming exercise in the context of a CS2 course using Python. All students struggled while completing the assignment, most notably experiencing difficulties with parameters and referencing elements with object-dot notation. While previous research has identified these areas as troublesome for novice programmers, our analysis suggests that parameters and reference specifications are particularly critical prerequisites for learning advanced object-oriented concepts with the Python programming language. Given our findings, we recommend extensive practice with parameter passing and object-dot notation before addressing advanced object-oriented concepts in a Python course.', 'url': 'https://doi.org/10.1145/2808006.2808017', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450338356', 'year': '2015', 'title': 'Learning Object-Oriented Programming in Python: Towards an Inventory of Difficulties and Testing Pitfalls', 'author': 'Miller, Craig S. and Settle, Amber and Lalor, John', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2808006.2808017'}
{'_id': '10.1145/2560032', 'keywords': "SoC, Python, scripting languages, Gillespie's Stochastic Simulation Algorithm, FPGA, VHDL, SysPy, Biomolecular reaction networks, Systems Biology, hw/sw co-design", 'numpages': '25', 'articleno': '84', 'month': 'March', 'journal': 'ACM Trans. Embed. Comput. Syst.', 'abstract': "We present SysPy (System Python) a tool which exploits the strengths of the popular Python scripting language to boost design productivity of embedded System on Chips for FPGAs. SysPy acts as a “glue” software between mature HDLs, ready-to-use VHDL components and programmable processor soft IP cores. SysPy can be used to: (i) automatically translate hardware components described in Python into synthesizable VHDL, (ii) capture top-level structural descriptions of processor-centric SoCs in Python, (iii) implement all the steps necessary to compile the user's C code for an instruction set processor core and generate processor specific Tcl scripts that import to the design project all the necessary HDL files of the processor's description and instantiate/connect the core to other blocks in a synthesizable top-level Python description. Moreover, we have developed a Hardware Abstraction Layer (HAL) in Python which allows user applications running in a host PC to utilize effortlessly the SoC's resources in the FPGA. SysPy's design capabilities, when complemented with the developed HAL software API, provide all the necessary tools for hw/sw partitioning and iterative design for efficient SoC's performance tuning. We demonstrate how SysPy's design flow and functionalities can be used by building a processor-centric embedded SoC for computational systems biology. The designed SoC, implemented using a Xilinx Virtex-5 FPGA, combines the flexibility of a programmable soft processor core (Leon3) with the high performance of an application specific core to simulate flexibly and efficiently the stochastic behavior of large size biomolecular reaction networks. Such networks are essential for studying the dynamics of complex biological systems consisting of multiple interacting pathways.", 'url': 'https://doi.org/10.1145/2560032', 'issn': '1539-9087', 'number': '4', 'volume': '13', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'issue_date': 'November 2014', 'year': '2014', 'title': 'Python to Accelerate Embedded SoC Design: A Case Study for Systems Biology', 'author': 'Logaras, Evangelos and Hazapis, Orsalia G. and Manolakos, Elias S.', 'ENTRYTYPE': 'article', 'ID': '10.1145/2560032'}
{'_id': '10.1145/2828959.2828969', 'series': "Koli Calling '15", 'location': 'Koli, Finland', 'keywords': 'computing education, Python, programming, program visualization, program animation, IDE', 'numpages': '5', 'pages': '117–121', 'booktitle': 'Proceedings of the 15th Koli Calling Conference on Computing Education Research', 'abstract': "Thonny is a new Python IDE for learning and teaching programming that can make program visualization a natural part of the beginners' workflow. Among its prominent features are different ways of stepping through the code, step-by-step expression evaluation, intuitive visualization of the call stack and mode for explaining the concepts of references and heap. It supports educational research by logging user actions for replaying or analyzing the programming process. It is free to use and open for extension.", 'url': 'https://doi.org/10.1145/2828959.2828969', 'address': 'New York, NY, USA', 'publisher': 'Association for Computing Machinery', 'isbn': '9781450340205', 'year': '2015', 'title': 'Introducing Thonny, a Python IDE for Learning Programming', 'author': 'Annamaa, Aivar', 'ENTRYTYPE': 'inproceedings', 'ID': '10.1145/2828959.2828969'}
